# GitHub Action definition file for Baler – the Bad Link Reporter.
#
# Copyright 2024 California Institute of Technology.
# License: Modified BSD 3-clause – see file "LICENSE" in the project website.
# Website: https://github.com/caltechlibrary/baler

name: "Baler – BAd Link reportER"
description: "Test links in repo files and file issues for problems found"

inputs:
  files:
    description: "Regexes for files to test. Can be comma-separated list."
    default: '*.md'
    required: true
    type: string
  ignore:
    description: "File containing a list of URLs to ignore, one per line."
    default: '.github/workflows/ignored-urls.txt'
    required: false
    type: string
  labels:
    description: "Labels assigned to GitHub issues created by this workflow."
    default: 'bug'
    required: false
    type: string
  lookback:
    description: "How many previous issues to check for duplicate reports."
    default: 5
    required: false
    type: number
  debug:
    description: "Run in debug mode."
    default: false
    required: false
    type: boolean

  # Internal parameters.
  lyVersion:
    description: "Version of lychee link checker program"
    default: 0.13.0
    required: false
  lyDownloadBase:
    description: "Base download URL for Lychee binaries"
    default: 'https://github.com/lycheeverse/lychee/releases/download'
    required: false

# Explanation for how different GitHub events are handled, and why:
#
# workflow_dispatch: Tests all .md files matched by ${{inputs.files}},
#     regardless of whether they have been modified in the latest commit.
#     Rationale: if you're invoking the action manually, you probably intend
#     to test the files as they exist in the repository now, and not relative
#     to a past commit or other past event.
#
# schedule: Tests all .md files matched by ${{inputs.files}}, regardless
#     of whether they have been modified in the latest commit. Rationale:
#     (1) it wouldn't make sense to have a nightly run test only the files
#     modified in the latest commit, because a previous commit might also
#     have modified some Markdown files, which means the latest commit is
#     not a good reference point for this purpose; and (2) regularly testing
#     all Markdown files, regardless of recent edits, is good for discovering
#     links that worked in the past but stopped working due to (e.g.) link
#     rot. In case #2, there are no local file changes.
#
# all other events: Test the .md files that are being changed as a result of
#     request, compared to the versions of the files in the destination
#     branch. The trigger/invocation is controlled by the trigger rules of
#     the invoking workflow. (So, for example, in the sample workflow
#     provided for users, pull requests result in testing .md files that were
#     modified by the pull request, but push events do not test any .md files
#     unless the push changes the workflow file itself or the file containing
#     the list of ignored urls.)

runs:
  using: composite
  steps:
    - name: Set preliminary run-time configuration variables.
      shell: bash
      run: |
        if [[ ${{github.event_name == 'push'}} ]]; then
          echo "depth_needed=2" >> $GITHUB_ENV
        elif [[ ${{github.event_name == 'pull_request'}} ]]; then
          echo "depth_needed=1" >> $GITHUB_ENV
        else
          echo "depth_needed=0" >> $GITHUB_ENV
        fi

    - name: Check out source repository.
      uses: actions/checkout@v3
      with:
        fetch-depth: ${{env.depth_needed}}
        persist-credentials: true

    - name: Get list of all files matching the desired pattern.
      uses: tj-actions/glob@v17
      id: match-files
      with:
        files: ${{inputs.files}}

    - name: Check if any files matching the pattern have been modified.
      id: test-changes
      uses: tj-actions/changed-files@v40
      with:
        files: ${{inputs.files}}

    - name: Construct list of files to act on.
      shell: bash
      run: |
        event=${{github.event_name}}
        if [[ "$event" == "workflow_dispatch" || "$event" == "schedule" ]]; then
          echo "considered=(${{steps.match-files.outputs.paths}})" >> $GITHUB_ENV
        elif [[ "${{steps.test-changes.outputs.any_changed}}" == "true" ]]; then
          echo "considered=(${{steps.test-changes.outputs.all_changed_files}})" >> $GITHUB_ENV
        fi

    - name: Decide whether to proceed.
      shell: bash
      run: |
        if [[ "${{steps.test-changes.outputs.any_changed}}" == "true" \
             || "${{github.event_name}}" == "workflow_dispatch" ]]; then
          echo "Continuing workflow."
          echo "continue=true" >> $GITHUB_ENV
        else
          message="## Files are unchanged
          Link testing was **skipped** because the relevant files have not
          changed. The files that were considered are the following:
          <code>${{inputs.files}}</code>"

          echo "$message" >> $GITHUB_STEP_SUMMARY
          echo "continue=false" >> $GITHUB_ENV
        fi

    - name: Install link checker program.
      if: env.continue == 'true'
      shell: bash
      run: |
        echo "Downloading and installing lychee binary."
        tarball=lychee-v${{inputs.lyVersion}}-x86_64-unknown-linux-gnu.tar.gz
        # First clean up artifacts from previous run in case it crashed.
        rm -rf $tarball lychee
        curl -sLO "${{inputs.lyDownloadBase}}/v${{inputs.lyVersion}}/$tarball"
        tar -xzf $tarball
        rm -f $tarball
        install -t "$HOME/.local/bin" -D lychee
        rm lychee
        echo "$HOME/.local/bin" >> "$GITHUB_PATH"

    - name: Configure link checker.
      if: env.continue == 'true'
      shell: bash
      run: |
        # Copy user's URL ignore list to file name expected by lychee.
        if [ -e ${{env.ignore}} ]; then
          cp -f ${{env.ignore}} .lycheeignore
          echo "Using file of URLs to ignore: ${{env.ignore}}"
        else
          echo "File of URLs to ignore does not exist: ${{env.ignore}}"
        fi
        # Create configuration file for lychee.
        lychee_config=.git/lychee.toml
        cat <<EOF > ${lychee_config}
        scheme = ["https", "http"]
        cache = false
        no_progress = true
        timeout = 30
        retry_wait_time = 30
        max_retries = 3
        include_mail = false
        include_verbatim = true
        exclude_all_private = true
        insecure = true
        EOF
        # Set variables used in later steps.
        echo "lychee_config=${lychee_config}" >> $GITHUB_ENV
        echo "lychee_output=.git/lychee-report.md" >> $GITHUB_ENV

    # Implementation notes:
    # - This purposefully doesn't use lychee's caching facility, because
    #   turning it on results in lychee NOT reporting the ORIGINAL error when
    #   a cached URL is encountered. This is very unhelpful in this context.
    #
    # - More information about optional settings for the lychee-action GHA
    #   can be found at https://github.com/lycheeverse/lychee-action
    #
    # - The documented exit codes for lychee are as follows (based on
    #   https://github.com/lycheeverse/lychee#exit-codes as of 2023-12-14):
    #    0 = success (links checked successfully or skipped as configured)
    #    1 = missing inputs, unexpected runtime failure, or config error
    #    2 = link check failures (if any non-excluded link failed the check)
    #    3 = errors in the config file

    - name: Run link checker to test URLs inside Markdown files.
      if: env.continue == 'true'
      shell: bash {0}
      continue-on-error: true
      run: |
        lychee_tmp="$(mktemp)"
        changed_files=${{env.considered}}
        lychee -c ${{env.lychee_config}} -o $lychee_tmp -f markdown ${changed_files[@]}
        exit_code=$?
        echo "lychee_exit_code=$exit_code" >> $GITHUB_ENV
        if [[ $exit_code == 2 ]]; then
          sed -e 's/^## Summary//' \
              -e 's/^|.*//g' \
              -e 's/^## Errors per input//' \
              -e 's/{.*$//g' \
              -e 's/| Failed:/– Failed:/g' \
              -e 's/| Timeout:/– Timeout:/g' \
              -e 's/\(.*\)\[\(.*\)\]\(.*\)/\1[`\2`]\3/' \
              < $lychee_tmp > ${{env.lychee_output}}
          echo >> ${{env.lychee_output}}
          endpoint="https://github.com/${GITHUB_REPOSITORY}/actions/runs"
          workflow="$endpoint/${GITHUB_RUN_ID}?check_suite_focus=true"
          echo -n "This content was produced by a " >> ${{env.lychee_output}}
          echo "[GitHub Action]($workflow)."        >> ${{env.lychee_output}}
        elif [[ $exit_code == 1 || $exit_code == 3 ]]; then
          message="## Run-time error
          Baler encountered an exception. This was most likely caused by a
          bug in Baler itself. Please report this to the developers. You can
          report it by opening an issue in the GitHub repository at
          <https://github.com/caltechlibrary/baler>."

          echo "$message" >> $GITHUB_STEP_SUMMARY
          echo "continue=false" >> $GITHUB_ENV
        fi

    - name: Check if we've already opened a duplicate issue.
      if: env.continue == 'true'
      shell: bash
      run: |
        sed_cmd='s/\\(.*\\)This content was produced by.*/\\1/'
        # Save a version of the current issue body, to use for comparisons.
        # Strip the end of the body b/c it has this workflow's unique run
        # id, which can never match any other issue. Also, sort the body;
        # this is a way to normalize the contents to avoid false positives
        # when, e.g., two runs end up putting URLs in different orders.
        current=$(sed $sed_cmd < ${{env.lychee_output}} | sort)
        # Get the issue numbers for the last N issues, where N = lookback.
        accept="Accept: application/vnd.github+json"
        auth="Authorization: Bearer ${{github.token}}"
        issues_endpoint="https://api.github.com/repos/${{github.repository}}/issues"
        url="$issues_endpoint?q=state:all&per_page=${{inputs.lookback}}"
        issues=$(curl -s -H $accept -H $auth $url)
        issue_numbers=$(jq '.[]number' <<<"$issues")
        # Iterate over the issues & compare the bodies.
        for number in $issue_numbers; do
          previous=$(curl -s -H $accept -H $auth $issues_endpoint/$number | jq '.body')
          previous=$(echo "$previous" | sed $sed_cmd | sort)
          if [[ "$current" == $previous" ]]; then
            # Report that we found a match, and stop execution.
            link="https://github.com/${{github.repository}}/issues/$number"
            message="## Invalid URL(s) previously reported
            One or more invalid URL(s) have been found; however, no new issue
            has been opened in the repository because the same invalid URL(s)
            were previously reported in [issue \#$number]($link)."

            echo "$message" >> $GITHUB_STEP_SUMMARY
            echo "continue=false" >> $GITHUB_ENV
            break
          fi
        done

    - name: Open a new issue/ticket to report the problems.
      if: env.continue == 'true'
      id: create-issue
      uses: peter-evans/create-issue-from-file@v4
      with:
        title: Invalid URLs in Markdown files
        content-filepath: ${{env.lychee_output}}
        labels: ${{env.labels}}
        token: ${{github.token}}

    - name: Put a link to the issue in the workflow output.
      if: env.continue == 'true'
      env:
        issue-number: ${{steps.create-issue.outputs.issue-number}}
      shell: bash
      run: |
        number="${{env.issue-number}}"
        link="https://github.com/${{github.repository}}/issues/$number"
        message="## Invalid URLs found
        Ticket [#${{env.issue-number}}]($link) has been created."
        echo "$message" >> $GITHUB_STEP_SUMMARY

    - name: Report if checks were successful.
      if: env.continue == 'true'
      shell: bash
      run: |
        message="## No invalid URLs found
        No bad links were found in the files matched by this pattern:
        <code>${{inputs.files}}</code>"
        echo "$message" >> $GITHUB_STEP_SUMMARY

    - name: Log internal variable values, in case they're needed for debugging.
      shell: bash
      run: |
        echo "Summary of run-time variables"
        echo "============================="
        echo "repository_owner = ${{github.repository_owner}}"
        echo "repository = ${{github.event.repository.name}}"
        echo "event name = ${{github.event_name}}"
        echo "files: ${{inputs.files}}"
        echo "ignore: ${{inputs.ignore}}"
        echo "labels: ${{inputs.labels}}"
        echo "depth_needed (for git history) = ${{env.depth_needed}}"
        echo "files considered = ${{env.considered}}"
        echo "continue = ${{env.continue}}"
        echo "env.lychee_exit_code = ${{env.lychee_exit_code}}"
        echo "============================="


author: "Michael Hucka -- https://github.com/mhucka"
branding:
  icon: cloud-off
  color: orange
